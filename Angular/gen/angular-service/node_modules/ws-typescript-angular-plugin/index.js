"use strict";
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
const createLanguageServicePlugin_1 = require("@volar/typescript/lib/quickstart/createLanguageServicePlugin");
const code_1 = require("./code");
const decorateLanguageServiceModule = require("@volar/typescript/lib/node/decorateLanguageService");
const utils_1 = require("@volar/typescript/lib/node/utils");
const transform_1 = require("@volar/typescript/lib/node/transform");
const tcbBlocks = new Map();
let decorated = false;
const windowsPathReg = /\\/g;
patchVolarToDecorateIdeCommands();
function patchVolarToDecorateIdeCommands() {
    if (decorated)
        return;
    decorated = true;
    let { decorateLanguageService } = decorateLanguageServiceModule;
    // @ts-ignore TS2540
    decorateLanguageServiceModule.decorateLanguageService =
        (language, languageService) => {
            decorateLanguageService(language, languageService);
            decorateIdeCommands(language, languageService);
        };
}
function loadLanguagePlugins(ts, info) {
    if (!addedCommands) {
        addNewCommands(ts, info);
        addedCommands = true;
    }
    return [{
            getLanguageId(scriptId) {
                return scriptId.endsWith(".html") ? "ng-html" : undefined;
            },
            createVirtualCode(scriptId, languageId, snapshot) {
                if (languageId !== "ng-html")
                    return undefined;
                let virtualCode = tcbBlocks.get(scriptId);
                if (!virtualCode) {
                    virtualCode = new code_1.AngularVirtualCode("ng-html");
                    tcbBlocks.set(scriptId, virtualCode);
                }
                return virtualCode; // tcbBlocks.get(scriptId)?.checkUpdate(snapshot, languageId)
            },
            updateVirtualCode(_scriptId, virtualCode, newSnapshot) {
                return virtualCode; //?.checkUpdate(newSnapshot)
            },
            typescript: {
                extraFileExtensions: [],
                getServiceScript(rootVirtualCode) {
                    return {
                        code: rootVirtualCode,
                        extension: ".ts",
                        scriptKind: ts.ScriptKind.TS
                    };
                }
            }
        }];
}
const ngTranspiledTemplateCommand = "ngTranspiledTemplate";
let addedCommands = false;
function addNewCommands(ts, info) {
    let projectService = info.project.projectService;
    projectService.logger.info("Angular: called handler processing");
    let session = info.session;
    if (session == undefined) {
        projectService.logger.info("Angular: there is no session in info.");
        return;
    }
    if (session.addProtocolHandler == undefined) {
        // addProtocolHandler was introduced in TS 4.4 or 4.5 in 2021, see https://github.com/microsoft/TypeScript/issues/43893
        projectService.logger.info("Angular: there is no addProtocolHandler method.");
        return;
    }
    session.addProtocolHandler(ngTranspiledTemplateCommand, ngTranspiledTemplateHandler.bind(null, ts, projectService));
    projectService.logger.info("Angular specific commands are successfully added.");
}
const ngTranspiledTemplateHandler = (_ts, _projectService, request) => {
    const requestArguments = request.arguments;
    const fileName = requestArguments.file;
    let virtualCode = tcbBlocks.get(fileName);
    if (virtualCode === undefined) {
        virtualCode = new code_1.AngularVirtualCode("ng-html");
        tcbBlocks.set(fileName, virtualCode);
    }
    virtualCode.update(requestArguments.content, requestArguments.transpiledContent, requestArguments.mappings);
    return {
        responseRequired: true,
        response: {}
    };
};
const init = (0, createLanguageServicePlugin_1.createLanguageServicePlugin)(loadLanguagePlugins);
function decorateIdeCommands(language, languageService) {
    let { getElementType } = languageService;
    if (getElementType === undefined)
        return;
    languageService.getElementType =
        (ts, fileName, range, forceReturnType) => {
            const [serviceScript, sourceScript, map] = (0, utils_1.getServiceScript)(language, fileName);
            const program = languageService.getProgram();
            const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(fileName);
            if (serviceScript && sourceFile) {
                let angularCode = serviceScript.code;
                let originalFile = {
                    text: angularCode.sourceCode,
                    getLineAndCharacterOfPosition(position) {
                        return ts.getLineAndCharacterOfPosition(this, position);
                    }
                };
                try {
                    let originalRangePosStart = ts.getPositionOfLineAndCharacter(originalFile, range.start.line, range.start.character);
                    let originalRangePosEnd = ts.getPositionOfLineAndCharacter(originalFile, range.end.line, range.end.character);
                    const generatedRangePosStart = (0, transform_1.toGeneratedOffset)(sourceScript, map, originalRangePosStart, () => true);
                    const generatedRangePosEnd = (0, transform_1.toGeneratedOffset)(sourceScript, map, originalRangePosEnd, () => true);
                    if (generatedRangePosStart !== undefined && generatedRangePosEnd !== undefined) {
                        const start = ts.getLineAndCharacterOfPosition(sourceFile, generatedRangePosStart);
                        const end = ts.getLineAndCharacterOfPosition(sourceFile, generatedRangePosEnd);
                        return getElementType(ts, fileName, { start, end }, forceReturnType);
                    }
                }
                catch (e) {
                    // ignore
                }
                return undefined;
            }
            else {
                return getElementType(ts, fileName, range, forceReturnType);
            }
        };
}
module.exports = init;
