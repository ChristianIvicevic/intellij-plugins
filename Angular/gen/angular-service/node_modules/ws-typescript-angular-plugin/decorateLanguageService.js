"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateNgLanguageServiceExtensions = exports.decorateIdeLanguageServiceExtensions = void 0;
const utils_1 = require("@volar/typescript/lib/node/utils");
const transform_1 = require("@volar/typescript/lib/node/transform");
const code_1 = require("./code");
function decorateIdeLanguageServiceExtensions(language, languageService) {
    let { webStormGetElementType, webStormGetTypeProperties, webStormGetSymbolType } = languageService;
    if (webStormGetElementType === undefined || webStormGetElementType === undefined || webStormGetSymbolType === undefined)
        return;
    languageService.webStormGetElementType = (ts, fileName, range, forceReturnType, reverseMapper) => {
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript === null || targetScript === void 0 ? void 0 : targetScript.associatedOnly) {
            return undefined;
        }
        const program = languageService.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(fileName);
        const generatedFile = targetScript ? program === null || program === void 0 ? void 0 : program.getSourceFile(targetScript.id) : undefined;
        if (serviceScript && sourceFile && generatedFile) {
            try {
                let originalRangePosStart = ts.getPositionOfLineAndCharacter(sourceFile, range.start.line, range.start.character);
                let originalRangePosEnd = ts.getPositionOfLineAndCharacter(sourceFile, range.end.line, range.end.character);
                const generatedRangePosStart = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, originalRangePosStart, () => true);
                const generatedRangePosEnd = (0, transform_1.toGeneratedOffset)(language, serviceScript, sourceScript, originalRangePosEnd, () => true);
                if (generatedRangePosStart !== undefined && generatedRangePosEnd !== undefined) {
                    const start = ts.getLineAndCharacterOfPosition(generatedFile, generatedRangePosStart);
                    const end = ts.getLineAndCharacterOfPosition(generatedFile, generatedRangePosEnd);
                    //TODO support reverseMapper
                    return webStormGetElementType(ts, targetScript.id, { start, end }, forceReturnType);
                }
            }
            catch (e) {
                // ignore
            }
            return undefined;
        }
        else {
            return webStormGetElementType(ts, fileName, range, forceReturnType, reverseMapper);
        }
    };
    languageService.webStormGetSymbolType = (ts, symbolId, reverseMapper) => {
        //TODO support reverseMapper
        return webStormGetSymbolType(ts, symbolId, reverseMapper);
    };
    languageService.webStormGetTypeProperties = (ts, typeId, reverseMapper) => {
        //TODO support reverseMapper
        return webStormGetTypeProperties(ts, typeId, reverseMapper);
    };
}
exports.decorateIdeLanguageServiceExtensions = decorateIdeLanguageServiceExtensions;
function decorateNgLanguageServiceExtensions(language, languageService) {
    languageService.webStormNgUpdateTranspiledTemplate = (_ts, fileName, transpiledCode, sourceCode, mappings) => {
        var _a;
        const sourceScript = language.scripts.get(fileName);
        const virtualCode = (_a = sourceScript === null || sourceScript === void 0 ? void 0 : sourceScript.generated) === null || _a === void 0 ? void 0 : _a.root;
        if (sourceScript && virtualCode instanceof code_1.AngularVirtualCode) {
            virtualCode.transpiledTemplateUpdated(transpiledCode, sourceCode, mappings);
        }
    };
}
exports.decorateNgLanguageServiceExtensions = decorateNgLanguageServiceExtensions;
