"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchVolarAndDecorateLanguageService = void 0;
const decorateLanguageServiceModule = require("@volar/typescript/lib/node/decorateLanguageService");
const utils_1 = require("@volar/typescript/lib/node/utils");
const transform_1 = require("@volar/typescript/lib/node/transform");
const code_1 = require("./code");
let decorated = false;
function patchVolarAndDecorateLanguageService() {
    if (decorated)
        return;
    decorated = true;
    let { decorateLanguageService } = decorateLanguageServiceModule;
    // @ts-ignore TS2540
    decorateLanguageServiceModule.decorateLanguageService =
        (language, languageService) => {
            decorateLanguageService(language, languageService /* due to difference in TS version we need to cast to any */);
            decorateIdeLanguageServiceExtensions(language, languageService);
            decorateNgLanguageServiceExtensions(language, languageService);
        };
}
exports.patchVolarAndDecorateLanguageService = patchVolarAndDecorateLanguageService;
function decorateIdeLanguageServiceExtensions(language, languageService) {
    let { webStormGetElementType, webStormGetTypeProperties, webStormGetSymbolType } = languageService;
    if (webStormGetElementType === undefined || webStormGetElementType === undefined || webStormGetSymbolType === undefined)
        return;
    languageService.webStormGetElementType = (ts, fileName, range, forceReturnType, reverseMapper) => {
        const [serviceScript, sourceScript, map] = (0, utils_1.getServiceScript)(language, fileName);
        const program = languageService.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(fileName);
        const generatedFile = sourceScript ? program === null || program === void 0 ? void 0 : program.getSourceFile(sourceScript.id) : undefined;
        if (serviceScript && sourceFile && generatedFile) {
            // let angularCode = serviceScript.code as AngularVirtualCode
            // let originalFile = {
            //   text: angularCode.source[fileName] ?? "",
            //   getLineAndCharacterOfPosition(position: number): TS.LineAndCharacter {
            //     return ts.getLineAndCharacterOfPosition(this, position);
            //   }
            // }
            try {
                let originalRangePosStart = ts.getPositionOfLineAndCharacter(sourceFile, range.start.line, range.start.character);
                let originalRangePosEnd = ts.getPositionOfLineAndCharacter(sourceFile, range.end.line, range.end.character);
                const generatedRangePosStart = (0, transform_1.toGeneratedOffset)(sourceScript, map, originalRangePosStart, () => true);
                const generatedRangePosEnd = (0, transform_1.toGeneratedOffset)(sourceScript, map, originalRangePosEnd, () => true);
                if (generatedRangePosStart !== undefined && generatedRangePosEnd !== undefined) {
                    const start = ts.getLineAndCharacterOfPosition(generatedFile, generatedRangePosStart);
                    const end = ts.getLineAndCharacterOfPosition(generatedFile, generatedRangePosEnd);
                    //TODO support reverseMapper
                    return webStormGetElementType(ts, sourceScript.id, { start, end }, forceReturnType);
                }
            }
            catch (e) {
                // ignore
            }
            return undefined;
        }
        else {
            return webStormGetElementType(ts, fileName, range, forceReturnType, reverseMapper);
        }
    };
    languageService.webStormGetSymbolType = (ts, symbolId, reverseMapper) => {
        //TODO support reverseMapper
        return webStormGetSymbolType(ts, symbolId, reverseMapper);
    };
    languageService.webStormGetTypeProperties = (ts, typeId, reverseMapper) => {
        //TODO support reverseMapper
        return webStormGetTypeProperties(ts, typeId, reverseMapper);
    };
}
function decorateNgLanguageServiceExtensions(language, languageService) {
    languageService.webStormNgTcbBlocks = new Map();
    languageService.webStormNgUpdateTranspiledTemplate = (_ts, fileName, transpiledCode, sourceCode, mappings) => {
        let virtualCode = languageService.webStormNgTcbBlocks.get(fileName);
        if (virtualCode === undefined) {
            virtualCode = new code_1.AngularVirtualCode(fileName);
            languageService.webStormNgTcbBlocks.set(fileName, virtualCode);
        }
        virtualCode.transpiledTemplateUpdated(transpiledCode, sourceCode, mappings);
        let scriptSnapshot = virtualCode.originalSourceSnapshot;
        // Trigger rebuild of virtual script
        // language.scripts.set(fileName, {
        //   getText(start: number, end: number): string {
        //     return scriptSnapshot.getText(start, end)
        //   },
        //   getLength(): number {
        //     return scriptSnapshot.getLength()
        //   },
        //   getChangeRange(oldSnapshot: ts.IScriptSnapshot): ts.TextChangeRange | undefined {
        //     return scriptSnapshot.getChangeRange(oldSnapshot)
        //   },
        //   dispose() {
        //     return scriptSnapshot.dispose?.()
        //   }
        // }, virtualCode.languageId, language.plugins)
    };
}
