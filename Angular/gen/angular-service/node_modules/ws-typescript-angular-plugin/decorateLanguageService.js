"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchVolarAndDecorateLanguageService = void 0;
const decorateLanguageServiceModule = require("@volar/typescript/lib/node/decorateLanguageService");
const utils_1 = require("@volar/typescript/lib/node/utils");
const transform_1 = require("@volar/typescript/lib/node/transform");
const code_1 = require("./code");
let decorated = false;
function patchVolarAndDecorateLanguageService() {
    if (decorated)
        return;
    decorated = true;
    let { decorateLanguageService } = decorateLanguageServiceModule;
    // @ts-ignore TS2540
    decorateLanguageServiceModule.decorateLanguageService =
        (language, languageService, caseSensitiveFileNames) => {
            decorateLanguageService(language, languageService /* due to difference in TS version we need to cast to any */, caseSensitiveFileNames);
            decorateIdeLanguageServiceExtensions(language, languageService);
            decorateNgLanguageServiceExtensions(language, languageService);
        };
}
exports.patchVolarAndDecorateLanguageService = patchVolarAndDecorateLanguageService;
function decorateIdeLanguageServiceExtensions(language, languageService) {
    let { webStormGetElementType, webStormGetTypeProperties, webStormGetSymbolType } = languageService;
    if (webStormGetElementType === undefined || webStormGetElementType === undefined || webStormGetSymbolType === undefined)
        return;
    languageService.webStormGetElementType = (ts, fileName, range, forceReturnType, reverseMapper) => {
        const [serviceScript, sourceScript, map] = (0, utils_1.getServiceScript)(language, fileName);
        const program = languageService.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(fileName);
        const generatedFile = sourceScript ? program === null || program === void 0 ? void 0 : program.getSourceFile(sourceScript.id) : undefined;
        if (serviceScript && sourceFile && generatedFile) {
            try {
                let originalRangePosStart = ts.getPositionOfLineAndCharacter(sourceFile, range.start.line, range.start.character);
                let originalRangePosEnd = ts.getPositionOfLineAndCharacter(sourceFile, range.end.line, range.end.character);
                const generatedRangePosStart = (0, transform_1.toGeneratedOffset)(serviceScript, sourceScript, map, originalRangePosStart, () => true);
                const generatedRangePosEnd = (0, transform_1.toGeneratedOffset)(serviceScript, sourceScript, map, originalRangePosEnd, () => true);
                if (generatedRangePosStart !== undefined && generatedRangePosEnd !== undefined) {
                    const start = ts.getLineAndCharacterOfPosition(generatedFile, generatedRangePosStart);
                    const end = ts.getLineAndCharacterOfPosition(generatedFile, generatedRangePosEnd);
                    //TODO support reverseMapper
                    return webStormGetElementType(ts, sourceScript.id, { start, end }, forceReturnType);
                }
            }
            catch (e) {
                // ignore
            }
            return undefined;
        }
        else {
            return webStormGetElementType(ts, fileName, range, forceReturnType, reverseMapper);
        }
    };
    languageService.webStormGetSymbolType = (ts, symbolId, reverseMapper) => {
        //TODO support reverseMapper
        return webStormGetSymbolType(ts, symbolId, reverseMapper);
    };
    languageService.webStormGetTypeProperties = (ts, typeId, reverseMapper) => {
        //TODO support reverseMapper
        return webStormGetTypeProperties(ts, typeId, reverseMapper);
    };
}
function decorateNgLanguageServiceExtensions(language, languageService) {
    languageService.webStormNgUpdateTranspiledTemplate = (_ts, fileName, transpiledCode, sourceCode, mappings) => {
        var _a;
        const sourceScript = language.scripts.get(fileName);
        const virtualCode = (_a = sourceScript === null || sourceScript === void 0 ? void 0 : sourceScript.generated) === null || _a === void 0 ? void 0 : _a.root;
        if (sourceScript && virtualCode instanceof code_1.AngularVirtualCode) {
            virtualCode.transpiledTemplateUpdated(transpiledCode, sourceCode, mappings);
        }
    };
}
