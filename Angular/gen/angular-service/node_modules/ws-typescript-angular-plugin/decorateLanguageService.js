"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateNgLanguageServiceExtensions = exports.decorateIdeLanguageServiceExtensions = void 0;
const utils_1 = require("@volar/typescript/lib/node/utils");
const transform_1 = require("@volar/typescript/lib/node/transform");
const code_1 = require("./code");
function toSourceRange(sourceScript, language, serviceScript, range, filter) {
    for (const result of (0, transform_1.toSourceRanges)(sourceScript, language, serviceScript, range, filter)) {
        return result;
    }
    return undefined;
}
function decorateIdeLanguageServiceExtensions(language, languageService) {
    let { webStormGetElementType, webStormGetTypeProperties, webStormGetSymbolType } = languageService;
    if (webStormGetElementType === undefined || webStormGetElementType === undefined || webStormGetSymbolType === undefined)
        return;
    const ngReverseMapper = function (ts, sourceFile, generatedRange) {
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, sourceFile.fileName);
        if (targetScript === null || targetScript === void 0 ? void 0 : targetScript.associatedOnly) {
            return undefined;
        }
        const program = languageService.getProgram();
        const generatedFile = targetScript ? program === null || program === void 0 ? void 0 : program.getSourceFile(targetScript.id) : undefined;
        if (serviceScript && sourceFile && generatedFile) {
            try {
                let originalRangePosStart = ts.getPositionOfLineAndCharacter(generatedFile, generatedRange.start.line, generatedRange.start.character);
                let originalRangePosEnd = ts.getPositionOfLineAndCharacter(generatedFile, generatedRange.end.line, generatedRange.end.character);
                const sourceRange = toSourceRange(sourceScript, language, serviceScript, { pos: originalRangePosStart, end: originalRangePosEnd }, () => true);
                if (sourceRange !== undefined) {
                    return {
                        fileName: sourceRange[0],
                        pos: sourceRange[1].pos,
                        end: sourceRange[1].end
                    };
                }
            }
            catch (e) {
                // ignore
            }
        }
        return undefined;
    };
    languageService.webStormGetElementType = (ts, fileName, range, forceReturnType, reverseMapper) => {
        const [serviceScript, targetScript, sourceScript] = (0, utils_1.getServiceScript)(language, fileName);
        if (targetScript === null || targetScript === void 0 ? void 0 : targetScript.associatedOnly) {
            return undefined;
        }
        const program = languageService.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(fileName);
        const generatedFile = targetScript ? program === null || program === void 0 ? void 0 : program.getSourceFile(targetScript.id) : undefined;
        if (serviceScript && sourceFile && generatedFile) {
            try {
                let originalRangePosStart = ts.getPositionOfLineAndCharacter(sourceFile, range.start.line, range.start.character);
                let originalRangePosEnd = ts.getPositionOfLineAndCharacter(sourceFile, range.end.line, range.end.character);
                const generatedRange = (0, transform_1.toGeneratedRange)(language, serviceScript, sourceScript, { pos: originalRangePosStart, end: originalRangePosEnd }, () => true);
                if (generatedRange !== undefined) {
                    const start = ts.getLineAndCharacterOfPosition(generatedFile, generatedRange.pos);
                    const end = ts.getLineAndCharacterOfPosition(generatedFile, generatedRange.end);
                    return webStormGetElementType(ts, targetScript.id, { start, end }, forceReturnType, ngReverseMapper.bind(null, ts));
                }
            }
            catch (e) {
                // ignore
            }
            return undefined;
        }
        else {
            return webStormGetElementType(ts, fileName, range, forceReturnType, reverseMapper);
        }
    };
    languageService.webStormGetSymbolType = (ts, symbolId, _reverseMapper) => {
        return webStormGetSymbolType(ts, symbolId, ngReverseMapper.bind(null, ts));
    };
    languageService.webStormGetTypeProperties = (ts, typeId, _reverseMapper) => {
        return webStormGetTypeProperties(ts, typeId, ngReverseMapper.bind(null, ts));
    };
}
exports.decorateIdeLanguageServiceExtensions = decorateIdeLanguageServiceExtensions;
function decorateNgLanguageServiceExtensions(language, languageService) {
    languageService.webStormNgUpdateTranspiledTemplate = (_ts, fileName, transpiledCode, sourceCode, mappings) => {
        var _a;
        const sourceScript = language.scripts.get(fileName);
        const virtualCode = (_a = sourceScript === null || sourceScript === void 0 ? void 0 : sourceScript.generated) === null || _a === void 0 ? void 0 : _a.root;
        if (sourceScript && virtualCode instanceof code_1.AngularVirtualCode) {
            virtualCode.transpiledTemplateUpdated(transpiledCode, sourceCode, mappings);
        }
    };
}
exports.decorateNgLanguageServiceExtensions = decorateNgLanguageServiceExtensions;
