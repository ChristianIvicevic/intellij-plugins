<html><body><div class="definition"><pre><b>Compatible: </b>espressif,esp32-pinctrl<br/><b>Path: </b>WORKING_DIRECTORY/zephyr/dts/bindings/pinctrl/espressif,esp32-pinctrl.yaml</pre></div><div class="content">Espressif&#39;s pin controller is in charge of controlling pin configurations, pin functionalities and pin properties as defined by pin states. In its turn, pin states are composed by groups of pre-defined pin muxing definitions and user provided pin properties.<br/><br/>Each Zephyr-based application has its own set of pin muxing/pin configuration requirements. The next steps use ESP-WROVER-KIT&#39;s I2C_0 to illustrate how one could change a node&#39;s pin state properties. Though based on a particular board, the same steps can be tweaked to address specifics of any other target board.<br/><br/>Suppose an application running on top of the ESP-WROVER-KIT board, for some reason it needs I2C_0&#39;s SDA signal to be routed to GPIO_33. When looking at that board&#39;s original device tree source file (i.e., &#39;esp_wrover_kit.dts&#39;), you&#39;ll notice that the I2C_0 node is already assigned to a pre-defined state. Below is highlighted the information that most interests us on that file<br/><br/><code><span style="color:#808000;">#include&#32;</span><span style="color:#008000;font-weight:bold;">"esp_wrover_kit-pinctrl.dtsi"</span></code><br/><br/><code><span style="">&amp;</span><span style="color:#000080;font-weight:bold;">i2c0&#32;</span><span style="">{<br></span><span style="">&#32;&#32;&#32;&#32;...<br></span><span style="">&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">pinctrl-0&#32;</span><span style="">=&#32;&lt;&amp;</span><span style="color:#000080;font-weight:bold;">i2c0_default</span><span style="">&gt;;<br></span><span style="">&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">pinctrl-names&#32;</span><span style="">=&#32;</span><span style="color:#008000;font-weight:bold;">"default"</span><span style="">;<br></span><span style="">};</span></code><br/><br/>From the above excerpt, the pincrl-0 property is assigned the &#39;i2c0_default&#39; state value. This and other pin states of the board are defined on another file (in this case, &#39;esp_wrover_kit-pinctrl.dtsi&#39;) on the same folder of the DTS file. Check below the excerpt describing I2C_0&#39;s default state on that file<br/><br/><code><span style="color:#000080;font-weight:bold;">i2c0_default</span><span style="">:&#32;</span><span style="color:#000080;font-weight:bold;">i2c0_default&#32;</span><span style="">{<br></span><span style="">&#32;&#32;&#32;&#32;</span><span style="color:#000080;font-weight:bold;">group1&#32;</span><span style="">{<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">pinmux&#32;</span><span style="">=&#32;&lt;I2C0_SDA_GPIO21&gt;,<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&lt;I2C0_SCL_GPIO22&gt;;<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">bias-pull-up</span><span style="">;<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">drive-open-drain</span><span style="">;<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">output-high</span><span style="">;<br></span><span style="">&#32;&#32;&#32;&#32;};<br></span><span style="">};</span></code><br/><br/>Only the &#39;pinmux&#39; property above is actually required, other properties can be chosen if meaningful for the target application and, of course, supported by your target hardware. For example, some custom board may have an external pull-up resistor soldered to GPIO_21&#39;s pin pad, in which case, &#39;bias-pull-up&#39; could be no longer required.<br/><br/>Back to our fictional application, the previous I2C_0 state definition does not meet our expectations as we would like to route I2C_0&#39;s SDA signal to GPIO_33 instead of to GPIO_21. To achieve it, we need to update the &#39;pinmux&#39; property accordingly.<br/><br/>Note that replacing &#39;I2C0_SDA_GPIO21&#39; by &#39;I2C0_SDA_GPIO33&#39; is very tempting and may even work, however, unless you have checked the hardware documentation first, it is not recommended. That&#39;s because there are no guarantees that a particular IO pin has the capability to route any specific signal.<br/><br/>The recommendation is to check the pinmux macros definitions available for the target SoC in the following URL<br/><br/>https://github.com/zephyrproject-rtos/hal_espressif/tree/zephyr/include/dt-bindings/pinctrl<br/><br/>The ESP-WROVER-KIT board is based on the ESP32 SoC, in that case, we search through the file &#39;esp32-pinctrl.h&#39; in the above URL. Luckily for us, there is one definition on that file that corresponds to our needs<br/><br/><code><span style="color:#808000;">#define&#32;</span><span style="">I2C0_SDA_GPIO33&#32;\<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ESP32_PINMUX(</span><span style="color:#0000ff;">33</span><span style="">,&#32;ESP_I2CEXT0_SDA_IN,&#32;ESP_I2CEXT0_SDA_OUT)</span></code><br/><br/>Now, we go back to edit &#39;esp_wrover_kit-pinctrl.dtsi&#39; and create a new pin state on that file (or replace/update the one already defined) using the pinmux macro definition above, yielding<br/><br/><code><span style="color:#000080;font-weight:bold;">i2c0_default</span><span style="">:&#32;</span><span style="color:#000080;font-weight:bold;">i2c0_default&#32;</span><span style="">{<br></span><span style="">&#32;&#32;&#32;&#32;</span><span style="color:#000080;font-weight:bold;">group1&#32;</span><span style="">{<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">pinmux&#32;</span><span style="">=&#32;&lt;I2C0_SDA_GPIO33&gt;,<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&lt;I2C0_SCL_GPIO22&gt;;<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">bias-pull-up</span><span style="">;<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">drive-open-drain</span><span style="">;<br></span><span style="">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</span><span style="color:#660e7a;font-weight:bold;">output-high</span><span style="">;<br></span><span style="">&#32;&#32;&#32;&#32;};<br></span><span style="">};</span></code><br/><br/>With proper modifications, the same steps above apply when using different combinations of boards, SoCs, peripherals and peripheral pins.<br/><br/>Note: Not all pins are available for a given peripheral, it depends if that pin supports a set of properties required by the target peripheral.<br/><br/>      When defining a state, the pin muxing information is constrained to the definitions at &#39;hal_espressif&#39;, however, pin properties (like bias-push-pull, drive-open-drain, etc) can be freely chosen, given the property is meaningful to the peripheral signal and that it is also available in the target GPIO.<br/><br/>      Another thing worth noting is that all pin properties should be grouped. All pins sharing common properties go under a common group (in the above example, all pins are in &#39;group1&#39;). Other peripherals can have more than one group.</div></body></html>